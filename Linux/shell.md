# Shell
> bash, zsh等软件本质上是一个虚拟机环境，能解析执行对应的操作，各种Shell都是一门成熟的脚本语言
> command parser, 仅做简单的命令解析， 不适合复杂的环境。


---
设计一个简单的 Shell 是一个非常棒的项目，它能让你深入理解操作系统、进程管理和文件系统等核心概念。虽然“简单”是个相对的概念，但我们可以把目标定为一个能解析和执行基本命令、支持一些内建命令、并处理环境变量的 Shell。

---

## 设计一个简单 Shell 的核心工作

要设计一个简单的 Shell，你主要需要完成以下几个核心任务：

### 1. 命令行读取（Reading Input）

这是 Shell 的第一步。你需要一个循环来不断读取用户输入的命令。

* **实现：**
    * 使用 `getline()`（C++）或 `fgets()`（C）等函数从标准输入（`stdin`）读取一整行用户输入。
    * 处理 EOF（End-of-File）信号，以便用户可以通过 `Ctrl+D` 退出 Shell。
    * 显示一个提示符（如 `myshell> `）来告诉用户可以输入命令了。

### 2. 命令解析（Parsing Input）

用户输入的命令通常由命令名和参数组成，你需要将它们从一整行字符串中分离出来。

* **实现：**
    * 使用字符串分割函数（如 `strtok()` 或 C++ 的 `stringstream`）根据空格将输入的字符串分割成多个令牌（token）。
    * 第一个令牌通常是命令名，后续令牌是参数。
    * 处理引号（`"` 或 `'`）内的空格，确保它们不会被错误地分割。
    * 识别特殊字符，如 `&`（后台运行）、`|`（管道）、`<`、`>`（重定向），尽管一个简单的 Shell 可能不实现所有这些。

### 3. 命令执行（Executing Commands）

这是 Shell 的核心功能。你需要区分内建命令和外部命令。

* **内建命令（Built-in Commands）：**
    * 这些命令直接由 Shell 内部的代码实现，不涉及创建新进程。例如 `cd`（改变目录）、`exit`（退出 Shell）、`env`（显示环境变量）。
    * **实现：** 在解析到这些命令时，直接调用对应的内部函数来执行。

* **外部命令（External Commands）：**
    * 这些命令是独立的程序，例如 `ls`、`grep`、`gcc` 等。Shell 需要为它们创建一个新的进程来执行。
    * **实现：**
        1.  **`fork()`：** 使用 `fork()` 系统调用创建一个子进程。
        2.  **子进程：** 在子进程中，使用 `execvp()`（或 `execve()` 等）系统调用加载并执行外部命令。`execvp()` 会用新程序的代码和数据替换掉子进程的内存空间。
        3.  **父进程：** 在父进程（Shell 自身）中，通常会使用 `waitpid()` 系统调用等待子进程执行完毕，然后再显示提示符。如果命令后面有 `&`，则父进程不需要等待，直接继续。

### 4. 环境变量（Environment Variables）

环境变量是键值对形式的全局变量，它们存储了 Shell 和其他程序运行所需的信息，例如 `PATH`、`HOME`、`USER` 等。

* **实现：**
    * **存储：** 环境变量通常以字符串数组的形式传递给 `main` 函数（`char *envp[]`），或者可以通过 `extern char **environ;` 全局变量访问。
    * **访问：** 你可以使用 `getenv()` 函数获取某个环境变量的值。
    * **设置/修改：** 你可以使用 `setenv()` 或 `putenv()` 函数来设置或修改环境变量。
    * **显示：** 实现一个 `env` 内建命令来遍历并打印当前所有环境变量。
    * **传递给子进程：** 当使用 `execve()` 执行外部命令时，你可以显式地传递当前的环境变量给子进程。`execvp()` 会自动使用当前 Shell 的环境变量。

#### **环境变量是如何实现的？**

在 Unix/Linux 系统中，每个进程都有一个与之关联的环境块（environment block），它是一个字符串数组，每个字符串都是 `KEY=VALUE` 的形式。当一个进程被 `fork()` 出来时，子进程会继承父进程的环境变量副本。当你通过 `setenv()` 或 `putenv()` 修改环境变量时，只是修改了当前进程的环境变量副本。这些修改不会影响父进程或其他无关进程的环境变量。

---

### 5. `PATH` 变量与命令查找

`PATH` 环境变量是一个由冒号（`:`）分隔的目录列表。当你在 Shell 中输入一个外部命令时，Shell 会按照 `PATH` 中列出的顺序，在这些目录中查找对应的可执行文件。

* **`ls` 命令是如何查找的？**
    1.  当你输入 `ls` 时，Shell 首先会检查 `ls` 是不是一个**内建命令**。如果不是，它会继续查找外部命令。
    2.  Shell 获取 `PATH` 环境变量的值（例如，`"/usr/local/bin:/usr/bin:/bin"`）。
    3.  它会按顺序尝试在 `PATH` 中的每个目录里拼接命令名，并检查这个组合路径是否存在一个可执行文件：
        * `"/usr/local/bin/ls"`
        * `"/usr/bin/ls"`
        * `"/bin/ls"`
    4.  一旦找到第一个可执行的 `ls` 文件，Shell 就会使用这个完整路径来执行命令（通过 `fork()` 和 `execvp()`）。
    5.  如果遍历完 `PATH` 中的所有目录都没有找到，Shell 就会报错，显示“command not found”。
    6.  **注意：** 如果你输入的是 `./myprogram` 或 `/home/user/myprogram` 这样的**绝对路径或相对路径**，Shell 会直接使用这个路径来执行，而不会去查找 `PATH`。

* **实现：**
    * 获取 `PATH` 环境变量的值。
    * 将 `PATH` 值按 `:` 分割成各个目录。
    * 对于每个目录，拼接上命令名，然后使用 `access()` 系统调用检查文件是否存在且可执行。
    * 找到后，就使用该完整路径执行命令。

---

### 6. 错误处理与信号处理

一个健壮的 Shell 还需要处理各种错误情况和系统信号。

* **错误处理：**
    * 命令未找到。
    * 权限不足。
    * 文件不存在。
    * 参数错误。
    * `fork()` 或 `exec()` 失败。
    * **实现：** 使用 `perror()` 打印系统错误信息，并给出友好的错误提示。

* **信号处理：**
    * **`SIGINT` (Ctrl+C)：** 默认情况下，这会终止前台进程。Shell 通常会捕获这个信号，以避免 Shell 自身被终止，而是将其传递给前台的子进程。
    * **`SIGCHLD`：** 当子进程状态改变（例如终止）时发送。你可以捕获这个信号来清理僵尸进程，避免资源泄露。
    * **实现：** 使用 `signal()` 或 `sigaction()` 函数注册信号处理函数。

---

### 其他可以扩展的功能（进阶）

* **I/O 重定向：** `<`（输入重定向）、`>`（输出重定向）、`>>`（追加输出）。
* **管道（Pipes）：** `|`（将一个命令的输出作为另一个命令的输入）。
* **后台执行：** `&`。
* **作业控制：** `jobs`、`fg`、`bg`。
* **历史记录：** 记录并允许用户上下键浏览之前输入的命令。
* **命令补全：** `Tab` 键补全命令或文件名。

---

**总结来说，设计一个简单的 Shell 核心流程是：循环 -> 读取 -> 解析 -> 执行（内建或外部命令）。** 其中，外部命令的执行依赖 `fork()` 和 `execvp()` 这两个关键的系统调用，而 `PATH` 变量是 Shell 查找外部命令的“地图”。

这是一个充满挑战但也非常有意义的项目！你打算用什么编程语言来实现呢？
