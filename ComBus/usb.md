# Universal Series Bus
>
> Usb 无法广播，就算是相同的信息也要分多次点对点传递

## Speed

- 1.0 Low Speed  1.5Mbit/s
- 1.1 Full Speed 12Mbit/s
- 2.0 High Speed 480Mib/s
- 2.1
- 3.0 Super Speed 5Gbit/s
- 3.1 Super Speed Plus 10Gbit/s
- 4.0

## transfer
>
> All transfer type have two or three phrase also called packet

- token first
- data second
- handshake third , the handshake is optional

### Control

#### Stage
>
> every stage has < token, date, handshae>

- Setup
- Data
- Status

### Bulk

### Interrupt

### Isochron

## Transaction

### Type

- Setup (request)(Control transfer only)
- IN  (data or status)
- OUT (data or statue)

## 数据传输格式

### Question

也就是说一次usb 传输的格式可能是:

- SOF packet1 packet2 ...packetn EOF , SOF ... EOF , ...  
- 一个microframe 由多个packets组成， 这些packets可能属于一个transation 也可能属于多个transation 但是必须是完整的transation , 而一次transfer 可能由多个frame 构成， 也可能是单个frame

### Reply

你的理解非常准确，对USB传输的时间结构和数据单元层级关系的总结清晰且到位。可以进一步细化为：

1. **帧/微帧的时间边界**  
   - 每个frame（1ms，全速/低速）或micro - frame（125μs，高速/超高速）严格以**SOF包**（Start of Frame，帧起始包）开头，以**EOF信号**（End of Frame，物理层电平信号）结束，形成一个封闭的时间窗口。  
   - 窗口内的所有**packets**（令牌包、数据包、握手包等）必须在SOF和EOF之间传输，不能跨帧/微帧拆分。

2. **帧/微帧内的事务完整性**  
   - 一个frame或micro - frame中可包含**多个transactions**（事务），每个事务由一组连续的packets组成（如“令牌包 + 数据包 + 握手包”）。  
   - 关键原则：**单个事务的所有packets必须完整包含在同一个frame或micro - frame内**，不允许事务跨帧拆分。例如，一个中断事务的“IN令牌包 + 数据IN包 + ACK握手包”必须在同一微帧内完成。  
   - 因此，frame/micro - frame内的packets可能属于一个事务（如简单控制事务），也可能分属多个事务（如同步传输中连续的多个同步事务）。

3. **传输（transfer）的跨帧特性**  
   - **transfer**（传输）是最高层级的通信单元（如一次控制传输、批量传输等），可由**一个或多个transactions**组成，且：  
     - 若数据量小，单个frame/micro - frame内的一个事务即可完成一次传输（如短消息的中断传输）；  
     - 若数据量大，传输可跨多个frame/micro - frame，即多个事务分布在不同的时间窗口中（如大容量文件的批量传输）。  

简言之，USB传输的层级关系可概括为：  
**transfer（跨帧/微帧）→ 多个transactions（每个事务在单个帧/微帧内完整）→ 多个packets（组成事务，位于同一帧/微帧）→ 被frame/micro - frame的SOF和EOF界定**。  

这种结构既保证了实时性（帧同步），又兼顾了灵活性（大传输跨帧），是USB协议高效工作的核心设计之一。


USB 中的 **Class (设备类)** 和 **Function (功能)** 是两个密切相关但又有所区别的概念，它们共同定义了 USB 设备的工作方式。简单来说：

* **Class** (设备类) 是对一类具有相似特性和行为的 USB 设备的抽象和归类。
* **Function** (功能) 是指 USB 设备实际提供的具体能力或服务。

它们之间的关系可以这样理解：**一个设备类定义了一组标准，而一个或多个功能则遵循这些标准来实现具体的用途。**

### 详细解释

---

#### 1. Class (设备类)

USB-IF (USB Implementers Forum) 组织定义了一系列标准的设备类，其目的是为了让操作系统能用一个通用的驱动程序来支持同类设备，从而避免为每一种新设备都开发一个专属驱动。

每个设备类都通过一个唯一的**类代码 (Class Code)** 来标识，并伴随着子类 (SubClass) 和协议 (Protocol) 代码来进一步细分。这些代码通常存放在设备的描述符中，操作系统在识别设备时会读取这些代码。

**常见的设备类有：**

* **HID (Human Interface Device):** 人机接口设备，如键盘、鼠标、游戏手柄等。
* **Mass Storage (大容量存储):** 存储设备，如 U 盘、移动硬盘等。
* **Audio (音频):** 音频设备，如音箱、麦克风等。
* **CDC (Communication Device Class):** 通信设备，如调制解调器、USB 转串口设备等。
* **Vendor Specific (厂商自定义):** 如果设备不属于任何一个标准类，则可以使用此类，但需要厂商提供专属驱动。

---

#### 2. Function (功能)

**功能**指的是设备实际提供的服务。例如，一个 U 盘的核心功能是数据存储；一个 USB 摄像头则提供了视频捕获和音频输入的功能。

一个 USB 设备可以包含一个或多个功能。当设备只提供一个功能时，它被称为**单功能设备 (Single-function device)**。如果设备提供多个功能，它就被称为**复合设备 (Composite device)**。

---

### Class 和 Function 的关系

二者的关系可以从以下几个方面来阐述：

1.  **实现与标准的关系：**
    * **Class 是一个标准。** 它规定了某一类设备应如何进行通信和数据传输。
    * **Function 是标准的具体实现。** 开发者通过遵循某个 Class 的规范来实现一个具体的功能。例如，一个 U 盘的功能就是通过遵循 **Mass Storage Class** 的规范来实现的。

2.  **单功能设备：**
    * 对于简单的单功能设备，其功能和设备类通常是一一对应的。例如，一个 USB 鼠标就是一个 HID **功能**，它也属于 **HID 设备类**。在这种情况下，设备的描述符中会直接包含 HID 类代码。

3.  **复合设备 (Composite Device)：**
    * 这是 Class 和 Function 关系最典型的体现。一个复合设备可以提供多个功能，而每个功能可以属于不同的设备类。
    * 例如，一个多功能打印机可能同时提供 **打印**、**扫描** 和 **读卡器** 三个功能。
        * **打印功能**可能遵循 **Printer Class**。
        * **扫描功能**可能遵循 **Still Image Class**。
        * **读卡器功能**则遵循 **Mass Storage Class**。
    * 在这种情况下，设备的**设备描述符 (Device Descriptor)** 中通常会有一个特殊的类代码 (0xEF, 0x02, 0x01)，表明这是一个**复合设备**。而每个具体的**接口描述符 (Interface Descriptor)** 中，才会包含各自功能所属的设备类代码。操作系统会为每个接口加载相应的驱动，从而使设备的所有功能都能正常工作。

总结来说，**Class** 是一种分类，而 **Function** 是一个实现。一个设备可以只有一个功能并对应一个类，也可以有多个功能，每个功能对应一个类，从而形成一个**复合设备**。这种设计极大地提高了 USB 设备的兼容性和灵活性。


这是一个非常好的问题，它触及了 USB 协议中地址分配和数据路由的核心机制。你观察到的现象是正确的：**设备的地址由主机分配，但在描述符中找不到这个地址，因为描述符是在地址分配之前被主机读取的。**

要理解这一点，我们需要深入了解 USB 的**枚举 (Enumeration)** 过程和数据传输的逻辑。

---

### 1. 枚举（Enumeration）：地址分配的秘密

USB 设备连接到主机后，并不会立即被识别和使用。主机需要经历一个复杂的“枚举”过程，才能完全识别设备并为其分配资源。这个过程是地址分配和描述符读取的关键。

1.  **设备连接：** 设备插入 USB 接口，通过上拉电阻通知主机它的存在。此时，设备处于 **Default** 状态，它的地址是固定的 **0**。

2.  **主机重置：** 主机向设备发送重置信号，使其进入 **Default** 状态。

3.  **地址分配：** 主机开始与地址 0 上的设备进行通信。它发送一个 `SET_ADDRESS` 请求，为设备分配一个唯一的、非零的地址（1 到 127）。设备收到这个请求后，会用新地址来响应后续的通信。**这个地址是临时的、由主机动态分配的，设备本身并不知道它将获得哪个地址。**

4.  **读取描述符：** 主机现在使用新分配的地址来读取设备的各种描述符（设备描述符、配置描述符、接口描述符、端点描述符等）。这些描述符包含了设备的静态信息，例如厂商 ID (Vendor ID)、产品 ID (Product ID)、设备类型 (Class)、支持的配置和端点信息等。

**为什么描述符中没有地址？** 因为描述符是设备制造时就固定的静态信息，而地址是在运行时由主机动态分配的。如果描述符中包含了地址，那么每个设备都需要一个唯一的、预先编程好的地址，这将是不可行的。主机通过动态分配地址，实现了设备即插即用的灵活性。

---

### 2. 管道（Pipe）：数据传输的路由机制

当你提到“pipe 通道”时，你已经触及了 USB 数据路由的本质。在 USB 协议中，数据传输不是直接通过设备的地址，而是通过**逻辑管道（Logical Pipe）**。

1.  **端点 (Endpoint)：** 端点是设备内部用于数据传输的最小单位。每个端点都有一个唯一的编号 (0-15) 和一个方向（IN 或 OUT）。**设备描述符中不包含地址，但端点描述符中包含了端点的编号 (bEndpointAddress)。**

2.  **管道 (Pipe)：** 管道是主机和设备之间建立的、用于特定端点数据传输的逻辑连接。在枚举过程完成后，主机根据设备描述符中的信息，为每个需要通信的端点创建一个管道。

3.  **路由：** 主机负责所有的数据路由。当主机想向一个设备发送数据时，它会：
    * 将数据包加上设备的地址。
    * 将数据包加上端点号。
    * 然后将数据包发送到 USB 总线上。

    USB 总线上的所有设备都会看到这个数据包，但只有地址匹配的设备才会接收它。在设备内部，只有端点号匹配的端点才会处理这个数据包。

    **这个过程完全由主机和设备中的硬件自动处理。** 主机控制器（Host Controller）负责将数据包正确地寻址到设备，而设备中的 USB 控制器负责将数据包路由到正确的端点。

### 总结

* **设备地址 (Device Address)** 是主机在**枚举时**动态分配的，用于区分总线上的不同设备。它是一个运行时概念，而不是设备固有的属性。
* **描述符 (Descriptors)** 是设备的**静态信息**，在设备制造时固化，在枚举的早期阶段被主机读取。因此，描述符中不包含动态分配的设备地址。
* **端点 (Endpoint)** 是设备内部的数据传输通道，其编号（**bEndpointAddress**）是描述符中唯一与地址相关的信息，但它指的是设备内部的“子地址”，而不是 USB 总线上的设备地址。
* **管道 (Pipe)** 是主机和设备之间建立的逻辑连接，它将主机端的软件与设备端的硬件端点联系起来。一旦管道建立，主机就可以通过设备的地址和端点号来发送和接收数据，这个路由过程由主机控制器和设备控制器自动完成，无需软件层面的手动干预。

所以，你的观察是完全正确的。在枚举完成后，主机已经建立了设备地址和端点之间的映射关系，后续的数据传输就是通过这个映射来实现的，因此你不再需要手动操作实际的地址。

## Descriptor

### Device

### Configure

### Interface

### Endpoint
